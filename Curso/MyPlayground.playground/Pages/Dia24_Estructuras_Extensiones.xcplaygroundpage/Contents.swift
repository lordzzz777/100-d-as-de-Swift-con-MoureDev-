import Foundation


// ---- Extensiones (Extensions): ----


// Las extensiones en Swift son una característica...
// que te permite agregar nuevos métodos y propiedades...
// a tipos existentes, incluso aquellos que no has creado...
// tú mismo. Las extensiones son útiles para extender...
// la funcionalidad de clases, estructuras o enumeraciones...
// sin modificar directamente su código fuente.
// Esto proporciona una manera de organizar...
// y separar la lógica del programa de manera más clara y modular.

// Aquí hay un ejemplo simple para...
// ilustrar cómo se utiliza una extensión:

// Definición original de la clase
class MiClase {
    var numero: Int
    
    init(numero: Int) {
        self.numero = numero
    }
}

// Extensión de la clase con un nuevo método
extension MiClase {
    func duplicar() {
        numero *= 2
    }
}

// Uso de la clase y la extensión
var objeto = MiClase(numero: 5)
print(objeto.numero)  // Imprime: 5

objeto.duplicar()
print(objeto.numero)  // Imprime: 10

// En este ejemplo, MiClase se define...
// con una propiedad numero. Luego,...
// se utiliza una extensión para agregar...
// un nuevo método llamado duplicar().
// Después de la extensión,...
// se crea una instancia de MiClase...
// y se llama al método duplicar().
// Aunque el método no estaba presente...
// en la definición original de MiClase,...
// la extensión permite que...
// la clase tenga ese método.

// Las extensiones pueden agregar:

// Métodos:
// Funciones que pueden ser llamadas en instancias del tipo extendido.

// puedes definir métodos adicionales...
// para un tipo específico.
// Los métodos en este contexto son...
// funciones que están asociadas a ese...
// tipo particular y que pueden ser...
// llamadas en instancias de ese tipo.
// Pueden realizar operaciones específicas...
// o proporcionar funcionalidades...
// adicionales al tipo original.

// Definición de Método en Extensión:
// Dentro de la extensión,...
// puedes agregar métodos...
// utilizando la palabra clave func:


extension MiTipo {
    func nuevoMetodo() {
        // Cuerpo del método aquí
    }
}

// Uso del Método:
// Después de definir la extensión,...
// puedes llamar al nuevo método...
// en instancias del tipo extendido:

let instancia = MiTipo()
instancia.nuevoMetodo()

// Ventajas de Utilizar Métodos en Extensiones:

// Modularidad:
// Los métodos en extensiones permiten organizar...
// y modularizar el código de manera más efectiva.
// Puedes agrupar funciones relacionadas...
// en extensiones separadas, facilitando...
// la comprensión y el mantenimiento del código.

// Extensibilidad:
// Si necesitas agregar nuevas funcionalidades...
// a un tipo que no controlas directamente,...
// puedes hacerlo utilizando extensiones.
// sto es especialmente útil para tipos...
// de librerías o clases que provienen...
// de frameworks externos.

// Mejora de Legibilidad:
// Al agregar métodos específicos en extensiones,...
// puedes mejorar la legibilidad del código al...
// dividir la lógica en funciones más pequeñas...
// y centradas en una tarea específica.

// Ejemplo Práctico:
// Supongamos que tienes una estructura Punto...
// que representa un punto en un plano cartesiano.
// Puedes agregar un método para calcular la...
// distancia euclidiana entre dos puntos...
// utilizando una extensión:

struct Punto {
    var x, y: Double
}

extension Punto {
    func distanciaA(_ otroPunto: Punto) -> Double {
        let deltaX = x - otroPunto.x
        let deltaY = y - otroPunto.y
        return sqrt(deltaX * deltaX + deltaY * deltaY)
    }
}

let puntoA = Punto(x: 1.0, y: 2.0)
let puntoB = Punto(x: 4.0, y: 6.0)

let distancia = puntoA.distanciaA(puntoB)
print(distancia)  // Imprime: 5.0

// En este ejemplo, el método distanciaA(_:)...
// se agrega a la estructura Punto a través...
// de una extensión, proporcionando una...
// funcionalidad útil relacionada con la geometría.

// En resumen, los métodos en extensiones en Swift...
// son una herramienta poderosa para extender la...
// funcionalidad de los tipos existentes,...
// proporcionando una manera modular y organizada...
// de mejorar y agregar nuevas capacidades a tus tipos.


// Propiedades:
// Variables computadas o de instancia adicionales.
// puedes agregar propiedades que pueden ser variables...
// almacenadas o variables calculadas (computadas).

// Variables Almacenadas:
// Puedes agregar nuevas variables a un tipo existente...
// y proporcionarles un valor inicial. Estas variables...
// se almacenan directamente en la instancia del tipo extendido.

extension String {
    var longitud: Int {
        return count
    }
}

let texto = "Hola, mundo!"
print(texto.longitud)  // Imprime: 13

// En este ejemplo, hemos extendido el tipo...
// String para agregar una propiedad llamada...
// longitud, que proporciona la longitud del texto.

// Variables Calculadas:
// También puedes agregar propiedades calculadas,...
// que no almacenan un valor directamente,...
// sino que calculan y devuelven un valor...
// cada vez que se accede a ellas.

extension Double {
    var cuadrado: Double {
        return self * self
    }
}

let numero = 4.0
print(numero.cuadrado)  // Imprime: 16.0

// En este caso, hemos extendido el tipo Double...
// para agregar una propiedad calculada...
// llamada cuadrado, que devuelve el cuadrado del número.

// Ambos ejemplos muestran cómo las extensiones...
// permiten agregar propiedades a tipos existentes,...
// proporcionando funcionalidades adicionales sin...
// modificar directamente la definición del tipo original.

// Es importante tener en cuenta que las extensiones...
// en Swift no pueden agregar propiedades almacenadas...
// con almacenamiento adicional, como propiedades con...
// respaldo de almacenamiento. Sin embargo, sí pueden...
// agregar propiedades calculadas...
// y propiedades almacenadas computadas.

// Subíndices:
// Para agregar subíndices a tipos que no los tienen originalmente.
// es posible agregar subíndices a tipos que originalmente no los tienen.
// Los subíndices son una forma conveniente de acceder y modificar...
// valores en una instancia del tipo extendido...
// usando una sintaxis de subscript.

// Definición de Subíndices en Extensiones:
// Dentro de una extensión, puedes agregar...
// un subíndice utilizando la siguiente sintaxis:

extension MiTipo {
    subscript(index: Int) -> Element {
        // Cuerpo del subíndice aquí
    }
}

// MiTipo: 
// Es el tipo al que estás agregando el subíndice.

// index:
// Es el parámetro que representa el...
// índice para acceder al elemento.

// Element:
// Es el tipo de elementos almacenados en la colección.

// Implementación del Subíndice:
// Dentro del cuerpo del subíndice, debes proporcionar...
// la lógica para obtener y establecer el valor asociado...
// con el índice proporcionado. Aquí tienes un ejemplo...
// básico utilizando un array:

extension Array {
    subscript(safe index: Int) -> Element? {
        if index >= 0 && index < count {
            return self[index]
        } else {
            return nil
        }
    }
}

// En este ejemplo, se ha creado un subíndice...
// que permite el acceso seguro...
// a elementos de un array.
// Si el índice está dentro de los...
// límites del array, se devuelve el...
// elemento correspondiente.
// De lo contrario, se devuelve nil...
// para evitar un desbordamiento de índice.

// Uso del Subíndice:
// Después de definir la extensión con el...
// subíndice, puedes usarlo de la siguiente manera:

var miArray = [1, 2, 3]

if let elemento = miArray[safe: 1] {
    print(elemento)  // Imprime: 2
} else {
    print("Índice fuera de límites")
}

// En este ejemplo, el subíndice safe creado...
// en la extensión permite acceder al elemento...
// en el índice especificado de manera segura,...
// evitando posibles errores de índice fuera de límites.

// En resumen, los subíndices en extensiones...
// ofrecen una manera flexible de ampliar la...
// funcionalidad de los tipos en Swift,...
// permitiéndote acceder y manipular valores...
// de una manera más conveniente...
// y específica para tus necesidades.

// Inicializadores:
// Para proporcionar nuevas formas de inicializar el tipo.
// también puedes agregar nuevos inicializadores a tipos...
// existentes. Los inicializadores en una extensión...
// te permiten proporcionar nuevas formas de inicializar...
// un tipo, lo cual es útil cuando deseas extender la...
// funcionalidad de una clase, estructura o enumeración...
// y necesitas introducir nuevos puntos de entrada.

// Aquí hay un ejemplo que muestra cómo agregar...
// un nuevo inicializador a una estructura Fecha de la biblioteca estándar de Swift:

// Importante: Esto es solo un ejemplo didáctico y en la práctica no sería necesario,
// ya que Swift proporciona ya inicializadores muy completos para fechas.

import Foundation

// Definición original de la estructura
struct MiFecha {
    var dia: Int
    var mes: Int
    var anio: Int
}

// Extensión de la estructura con un nuevo inicializador
extension MiFecha {
    init(fechaTexto: String) {
        let components = fechaTexto.components(separatedBy: "-")
        guard components.count == 3,
              let dia = Int(components[0]),
              let mes = Int(components[1]),
              let anio = Int(components[2]) else {
            fatalError("Formato de fecha no válido: \(fechaTexto)")
        }

        self.dia = dia
        self.mes = mes
        self.anio = anio
    }
}

// Uso de la estructura y la extensión
let miFechaDesdeTexto = MiFecha(fechaTexto: "25-01-2024")
print("Día: \(miFechaDesdeTexto.dia), Mes: \(miFechaDesdeTexto.mes), Año: \(miFechaDesdeTexto.anio)")

// En este ejemplo, se ha creado una extensión...
// para la estructura MiFecha, la cual agrega...
// un nuevo inicializador que acepta una cadena...
// de texto en formato "dd-MM-yyyy" y crea una...
// instancia de la estructura con los componentes...
// de día, mes y año extraídos de esa cadena.

// Es importante mencionar que, aunque las...
// extensiones pueden agregar nuevos...
// inicializadores, no pueden agregar...
// inicializadores de conveniencia a una...
// clase, ya que estos deben ser proporcionados...
// en la propia declaración de la clase. Sin embargo,...
// sí pueden agregar inicializadores de conveniencia...
// a estructuras y enumeraciones.
